#!/usr/bin/env bc -Ll -f

define min(a, b) {
    if (a < b) return a
    return b
}

define max(a, b) {
    if (a > b) return a
    return b
}

define acos(a) {
    return a2(sqrt(1 - a ^ 2), a)
}

define void swap_array(*arr[], pos1, pos2) {
    auto t
    t = arr[pos1]
    arr[pos1] = arr[pos2]
    arr[pos2] = t
}

/* base64 encode array and print */
define void base64_encode_and_print(bytes[]) {
    auto i, codes, chunk, len, b, bit, b6, index

    len = length(bytes[])

    for (i = 0; i < len; i+=3) {
        b6 = 0
        for (b = 0; b < 24; b++) {
            index = i + b / 8

            bit = (band(bytes[index] * (2 ^ (b % 8)), 128) && 1)
            b6 = b6 * 2 + bit

            if (b % 6 == 5) {
                if (b6 < 26) print asciify(b6 + 65); else
                if (b6 < 52) print asciify(b6 - 26 + 97); else
                if (b6 < 62) print asciify(b6 - 52 + 48); else
                if (b6 < 63) print "+"; else print "/"

                if (index >= len) {
                    for (;len % 3; len++) print "="
                    break
                }

                b6 = 0
            }
        }
    }
}

/* print array */
define void print_array(b[]) {
    auto i

    for (i = 0; i<length(b[]); i++) {
        print b[i], " "
    }
    print "\n"
}

/***** My own graphics library for bc *****/

black_ = 0
white_ = 1

/* create new image */
define void img__new(*img[], w, h, bg) {
    auto x, y
    img[0] = w; img[1] = h

    for (y = 0; y < h; y++) for (x = 0; x < w; x++) img[2 + x + y * w] = bg
}

/* helper for packing binary data */
define v_pack(*bytes[], bsize, offset, d) {
    auto i, m

    for (i = 0; i < bsize / 8; i++) {
        d = divmod(d, 256, m[])
        bytes[i + offset] = m[0]
    }

    return i + offset
}

/* create mono BMP, encode by base64 and print */
define void img__monobmp(img[]) {
    auto b, s, bmp, size, i, x, y, wh, p

    scale = 10; wh = ceil(img[0] / 8, 0); scale = 0
    size = wh * img[1]

    bmp[s++] = 66; bmp[s++] = 77     /* BM */
    s = v_pack(bmp[], 32, s, 0)      /* space for Length */

    /* Main header */
    s = v_pack(bmp[], 16, s, 0)      /* Reserved */
    s = v_pack(bmp[], 16, s, 0)      /* Reserved */
    s = v_pack(bmp[], 32, s, 32)     /* Offset of image data */

    /* Subheader */
    s = v_pack(bmp[], 32, s, 12)      /* Subheader length */
    s = v_pack(bmp[], 16, s, img[0])  /* Width */
    s = v_pack(bmp[], 16, s, img[1])  /* Height */
    s = v_pack(bmp[], 16, s, 1)       /* Planes */
    s = v_pack(bmp[], 16, s, 1)       /* Bit count */

    /* Color table */
    bmp[s++] = bmp[s++] = bmp[s++] = 0;   /* black */
    bmp[s++] = bmp[s++] = bmp[s++] = 255; /* white */

    for (y = img[1] - 1; y >=0; y--) {
        p = bmp[s] = 0

        for (x = 0; x < img[0]; x += 8) {
            for (b = 0; b < 8; b++) {
                bmp[s] = bmp[s] * 2 + img[2 + x + b + y * img[0]]

                if (x + b >= img[0]) {
                    bmp[s] *= 2 ^ (wh - img[0])
                }
            }
            s += 1; p += 1
        }

        /* Row padding */
        for (; p % 4; p++) bmp[s++] = 0
    }

    s = v_pack(bmp[], 32, 2, length(bmp[])) /* Full length */

    base64_encode_and_print(bmp[])
}

/* Output image to iTerm2 terminal */
define void img__out_iterm2(img[], ratio) {
    print "]1337;File=inline=1;width=", img[0] * ratio, "px;height=", img[1] * ratio, "px:"
    img__monobmp(img[])
    "" 
}

/* Set pixel */
define void img__setpixel(*img[], x, y, color) {
    if (x < img[0] && y < img[1] && x >= 0 && y >= 0) img[2 + x + y * img[0]] = color
}

/* Get pixel */
define img__getpixel(*img[], x, y) {
    if (x < img[0] && y < img[1]) return img[2 + x + y * img[0]]

    return black_
}

/* Draw line */
define void img__line(*img[], x1, y1, x2, y2, color) {
    auto step, dx, sx, dy, sy, e, t, i

    step = 0
    dx = abs(x2 - x1)
    if (x2 - x1 > 0) sx = 1; else sx = -1
    dy = abs(y2 - y1)
    if (y2 - y1 > 0) sy = 1; else sy = -1

    if (dy > dx) {
        step = 1
        t = x1; x1 = y1; y1 = t
        t = dx; dx = dy; dy = t
        t = sx; sx = sy; sy = t
    }

    e = 2 * dy - dx

    for (i = 0; i < dx; i++) {
        if (step) img__setpixel(img[], y1, x1, color); else img__setpixel(img[], x1, y1, color)

        while (e >= 0) {
            y1 += sy
            e -= 2 * dx
        }

        x1 += sx
        e += 2 * dy
    }

    img__setpixel(img[], x2, y2, color)
}

/* Draw rectangle */
define void img__rectangle(*img[], x1, y1, x2, y2, color) {
    img__line(img[], x1, y1, x2, y1, color);
    img__line(img[], x2, y1, x2, y2, color);
    img__line(img[], x2, y2, x1, y2, color);
    img__line(img[], x1, y2, x1, y1, color);
}

/* Draw filled rectangle */
define void img__filled_rectangle(*img[], x1, y1, x2, y2, color) {
    auto hx, lx, x

    hx = min(max(x1, x2), img[0])
    lx = max(min(x1, x2), 0)

    for (x = lx; x <= hx; x++) img__line(img[], x, y1, x, y2, color)
}

/* Draw bitmap */
define void img__number_bitmap(*img[], x, y, number, w, h, invert) {
    auto ix, iy, pixel

    for (iy = 0; iy < h; iy++) for (ix = 0; ix < w; ix++) {
        number = divmod(number, 2, pixel[])
        img__setpixel(img[], x + ix, y + iy, bxor(pixel[0], invert))
    }
}

/**** Game code *****/

w_ = 128
h_ = 64
zoom_ = 4
map_size_ = 16 /* 16Ã—16 */

/*
map_ â€” map (16Ã—16)
z_ - z-buffer(128)
*/

player_points_ = num_killed_ = num_monsters_ = player_rotation_ = player_x_ = player_y_ = game_level_ =\
player_dead_ = player_rotation_ = fwd_ = u_ = 0
player_health_ = 64
moved_ = 1

scale = 20
rad_ = pi(15) / 180   /* used to convert angles to radians */
f_ = 30 * rad_        /* angle of view (larger distorts the "lens") */
dist_to_proj_plane_ = (64 / tan(f_)) @ 0 /* 110 pixels */
r_ = 2 * f_ / 128     /* this is the angle of each ray to cover 128 pixels */

player_eye_level_ = 32
inf_ = 1e300

c_180_ = pi(15)
c_90_ = c_180_ / 2
c_270_ = c_180 * 3 / 2

mscale = 0


sp_wall       = 115790325841308887754689319541375788545262201015676595078955512853657393562048
sp_5k         = 115791758266903294916915719918405839821729688100733916992900690226762151100415
sp_enemy      = 3604401011418865210367460462141013802062877445938327180701667453088288998384
sp_health     = 14459987026983748380479840405124610233720605349854119294648131602623749947392
sp_healthmask = 14460097021716575011009459698040769632580476913144945034209264182221644759040
sp_enemymask  = 3604423010853823540684956828583937595125500288817684492511162279594624025584
sp_gun        = 9074664992054167625921853607596205229656202490184025649120289457887141429248
sp_gunmask    = 14445962027823879042873831860576144858980204774643980420653335896405235990528
sp_dead       = 1781009664924204950550029277722341159179471590307587660868709914915001860096
sp_deadmask   = 1781036841271189239956981699968503370596684189380290459034487360571702247424
sp_fire       = 3040059354238675351661515896043897916288248265572352

font[0] = 31599 /* 3Ã—5 */
font[1] = 18740 /* 3Ã—5 */
font[2] = 29671 /* 3Ã—5 */
font[3] = 31207 /* 3Ã—5 */
font[4] = 18925 /* 3Ã—5 */
font[5] = 31183 /* 3Ã—5 */
font[6] = 31695 /* 3Ã—5 */
font[7] = 18727 /* 3Ã—5 */
font[8] = 31727 /* 3Ã—5 */
font[9] = 18927 /* 3Ã—5 */

for (i = 0; i < 128; i++) z_[i] = 0

/* Draw number */
define void draw_number(number, x, y, invert) {
    auto len, i, digit, m

    if (number) len = l10(number) @ 0 + 1; else len = 1

    for (i = 0; i<len; i++) {
        m = 10 ^ (len - i - 1)
        digit = number / m
        number -= digit * m

        img__number_bitmap(canvas[], x, y, font[digit], 3, 5, invert)
        x += 4
    }
}

define is_not_valid_location(x,y) {
    x /= 64
    y /= 64

    if (x < 0 || y < 0 || x > map_size_ - 1 || y > map_size_ - 1) {
        return 1
    }

    return map_[x @ 0 + map_size_ * y @ 0]
}


/* Init world map */
define void init_map() {
    auto i, wall_cnt, x, y
    for (i = 0; i < map_size_ * map_size_; i++) map_[i] = 0

    wall_cnt = 30 + 4 * game_level_

    while (wall_cnt) {
        x = irand(map_size_)
        y = irand(map_size_)

        if (x * y > 4) {
            map_[x + map_size_ * y] = 1
            wall_cnt -= 1
        }
    }
}

define void init_objects() {
    auto i, x, y, type, o_cnt, k

    om_cnt = 0

    /* clear objects */
    for (i = 0; i < length(o_[]); i++) o_[i] = 0

    i = 6 + 4 * game_level_

    while (i) {
        x = 64 * (irand(12) + 2)
        y = 64 * (irand(12) + 2)
        type = ((i % 8) && 1) /* 0 â€” health, 1 â€” monster */

        if (!is_not_valid_location(x, y)) {
            o_x_[o_cnt] = x
            o_y_[o_cnt] = y
            o_i_[o_cnt] = type
            k = 1 - 2 * brand() /* 1 or -1 */

            if (type) {
                o_dx_[o_cnt] = k * game_level_ * irand(64) / 4
                o_dy_[o_cnt] = k * game_level_ * irand(64) / 4
            } else {
                o_dx_[o_cnt] = 0
                o_dy_[o_cnt] = 0
            }

            o_z_[o_cnt] = o_c_[o_cnt] = 0

            o_[o_cnt++] = 1 /* object exists */

            i -= 1
            num_monsters_ += type
        }
    }
}

define draw_sprite(sprite, sprite_mask, sy, sx, dy, dx, check, invert) {
    auto height, width, canvas_changed, x, y, px, py, clr, msk

    height = abs(dy - sy)
    width  = abs(dx - sx)
    canvas_changed = 0

    if (sy < 0) sy = 0
    if (dy >= h_) dy = h_ - 1

    for (x = sx; x < dx; x++) {
        /* if $f is zero then we draw as long as it is on the screen
           otherwise check zBuffer which holds scanline information
           for visibility, if something already occupies the at
           a closer depth then we know that whatever we were
           attempting to draw
           is hidden so we do not draw it */

        if (x >= 0 && k <= w_) {
            if (!(check && (check > z_[x]))) {
                px = band(16 * (x - sx) / width, 15)

                for (y = sy; y < dy; y++) {
                    py = 16 * (y - sy) / height

                    clr = (band(sprite / (2 ^ (16 * py)), 2 ^ px) && 1)
                    msk = (band(sprite_mask / (2 ^ (16 * py)), 2 ^ px) && 1)

                    if (msk) {
                        img__setpixel(canvas[], x, y, bxor(clr, invert))
                        canvas_changed = 1
                    }
                }
            }
        }
    }

    return canvas_changed
}

define void clear_terminal() {
    print "[2J"
}


define void show_screen(red) {
    print "[H"
    img__out_iterm2(canvas[], zoom_)
}

define void start() {
    game_level_ += 1
    player_x_ = player_y_ = 128
    num_killed_ = num_monsters_ = player_rotation_ = 0;

    img__new(canvas[], w_, h_ + 8, black_)
    img__filled_rectangle(canvas[], 0, h_, w_ - 1, h_ + 7, white_)
    draw_number(game_level_, w_ / 2 - 2, h_ / 2, 0)

    show_screen(0)

    init_map()
    init_objects()
}

define void ray_cast() {
    auto c2, a, a6, d, lht, c1, u, uh, uv, a5, a4, f, d2, dx, dy, d_b, q,\
    r, s, t, o, p, ht, d_a, v, dd, k, l, a0, b1, b2, pat, res

    img__new(canvas[], w_, h_ + 8, black_)
    img__filled_rectangle(canvas[], 0, h_, w_ - 1, h_ + 7, white_)

    c2 = -f_ /* f_ is the view angle, the larger f_ is the more we cram into the view area */
    a = player_rotation_ + c2
    a6 = -1
    uh = uv = 0
    a5 = inf_

    f = 0

    /* what scanline we are working on (0-128) */
    for (v = 0; v < w_; v++) {
        c1 = f
        lht = ht

        scale = 20
        c = cos(a)
        s = sin(a)
        t = s / c
        scale = 0

        /* if a is 0 or 180 then we get a divide by zero error so we ignore the ray */
        if (!a || a == c_180_) {
            a4 = inf_
        } else {
            scale = 20

            if (s > 0) {
                d_b = 64 * ((player_y_ / 64 + 1) @ 0)   /* start at the tile in front of the player */
                dy = 64                                 /* increment in whole tiles forward */
                d_a = player_x_ + (d_b - player_y_) / t /* start with an adjustment to the side of the player */
                dx = 64 / t                             /* increment 64/t to the side (plot chart) */
            } else {
                /* otherwise we are facing backwards so we go in the opposite direction */
                d_b = ((player_y_ / 64) @ 0) * 64 - .0001
                dy = -64
                d_a = player_x_ + (d_b - player_y_) / t
                dx = -64 / t
            }
            scale = 0

            /* while we have not hit a wall tile or edge of the map */
            while(!is_not_valid_location(d_a, d_b)) {
                d_a += dx /* keep shooting the ray */
                d_b += dy
            }

            q  = d_a  /* store the final location where the ray hits a wall tile */
            r  = d_b
            scale = 20; a4 = abs((player_x_ - d_a) / c); scale = 0

            uh = d_a % 64;   /* the pattern repeats every 64 pixels. */

            if (s > 0) {
                uh = 64 - uh    /* flip the pattern */
            }
        }

        /* if we are at 90 or 270 degrees our ray has infinite problems */
        if (a == c_90_ || a == c_270_) {
            a5 = inf_
        } else {
            scale = 20
            if (c > 0) {
                d_a = ((player_x_ / 64 + 1) @ 0) * 64 /* start one tile in front of player */
                dx  = 64
                d_b = player_y_ + (d_a - player_x_) * t
                dy  = 64 * t
            } else {
                d_a = ((player_x_ / 64) @ 0) * 64 - .0001 /* start just behind player */
                dx  = -64
                d_b = player_y_ + (d_a - player_x_) * t   /* at 90 and 270, t goes to infinity so multiplying */
                                                          /* results in an invalid number */
                dy  = -64 * t
            }
            scale = 0

            /* again look for the first wall tile we hit */
            while (!is_not_valid_location(d_a, d_b)) {
                d_a += dx
                d_b += dy
            }

            s = d_a
            t = d_b
            scale = 20; a5 = abs((player_x_ - d_a) / c); scale = 0
            uv = d_b % 64;
            if (c < 0) {
                uv = 64 - uv
            }
        }

        d = a6
        /* we are looking for the smallest distance to travel
           both rays cannot be infinite at once so we pick the one
           that is not infinite */
        if (a4 < a5) {
            u  = uh /* texture scanline */
            f  = a4 /* distance from camera */
            a6 = 0
            o  = q  /* map x position */
            p  = r  /* map y position */
        } else {
            u  = uv /* text scanline */
            f  = a5 /* distance from camera */
            a6 = 1
            o  = s /* map x position */
            p  = t /* map y position */
        }

        scale = 20
        f *= cos(c2)

        z_[v] = f /* z-buffer, f is the depth of the scanline */

        ht = (64 / f * dist_to_proj_plane_) @ 0 /* height of the scanline */
        dd = abs(c1 - f) /* change in distance from previous f */
        k = (player_eye_level_ - ht / 2) @ 0 /* the top of our scanline */
        l = (player_eye_level_ + ht / 2) @ 0 /* the bottom of the scanline */

        if (k < 0) { /* make sure we are not trying to draw above the view area */
            k = 0
        }

        b3 = k  /* starting position for scanning */

        /* a0 is the x pixel position in the texture
           u will go from 0 to 63 so dividing by 4 gets us 0 to 15*/

        a0 = (u / 4) @ 0

        if (dd > 64 && lht > ht) {  /* Lht is the previous scanline height */
            ht = lht
        }

        if (l >= h_) { /* if l is greater than the height of the view area then adjust */
            l = h_ - 1
        }

        x = (o / 64) @ 0 /* our tile position */
        y = (p / 64) @ 0

        scale = 0

        /* if we're out of bounds of the map
           and the level is less than 5 then
           alternate wall tiles
           otherwise use the enemy sprite as a wall
           tile and alternate it.
           if we're in bounds then use the default
           wall tile 0 */

        if ((x<0 || x>15) && (y % 2)) {
            pat = sp_5k
        } else {
            if (game_level_ > 4) pat = sp_enemy; else pat = sp_wall
        }

        /* start at the top of the scanline and work down */
        for (y = k; y < l; y++) {
            /* the row of pixels is based on the current y
             y position. >>2 divides by 4.  64/4==16 */

            scale = 20
            b1 = (((y - b3) / ht * 64) / 4) @ 0
            scale = 0

            /* we're subtracting from 15 because the tiles
               are stored upside down */
            b2 = (band(pat / (2 ^ (16 * b1)), 2 ^ a0) && 1)

            res = (b2 || /* is the color 1 or 0? */ \
                (v && d != a6) || /* is v 0 and d not equal to a6 (d is the prior version of a6) */ \
                (dd >= 64 && v) || /* if our change in distance is greater than 64 and v is non 0 */ \
                (f >= 64*3 && f < 64*4 && v % 4 == y % 4) || /* skip pixels based on distance from player */ \
                (f >= 64*4 && f < 64*6 && v % 3 == y % 3) || /* this is how the "lighting" is done */ \
                (f >= 64*6 && v % 2 == y % 2))

            if (!res) {
                /* if after all of the checks we having something to plot */
                img__setpixel(canvas[], v, y, white_)
            }
        }

        a  += r_  /* increment the ray angle */
        c2 += r_
    }
}

define void swap_o(pos1, pos2) {
    swap_array(o_a_[],  pos1, pos2)
    swap_array(o_c_[],  pos1, pos2)
    swap_array(o_d_[],  pos1, pos2)
    swap_array(o_dx_[], pos1, pos2)
    swap_array(o_dy_[], pos1, pos2)
    swap_array(o_i_[],  pos1, pos2)
    swap_array(o_l_[],  pos1, pos2)
    swap_array(o_r_[],  pos1, pos2)
    swap_array(o_x_[],  pos1, pos2)
    swap_array(o_y_[],  pos1, pos2)
    swap_array(o_z_[],  pos1, pos2)
    swap_array(o_[],    pos1, pos2)
}

define void quicksort_o(left, right) {
    auto pivot_index

    if (left < right) {
        pivot_index = partition_o(left, right)
        quicksort_o(left, pivot_index - 1)
        quicksort_o(pivot_index + 1, right)
    }
}

define partition_o(left, right) {
    auto i, j, pivot

    pivot = o_d_[right]
    i = left - 1
    for (j = left; j < right; j++) {
        if (o_d_[j] >= pivot) {
            i += 1
            swap_o(i, j)
        }
    }
    swap_o(i + 1, right)
    return i + 1
}

define void sort_o() {
    quicksort_o(0, length(o_[]) - 1)
}

define void tick() {
    auto i, cz, tx, ty, x, y, ht, k, l, pat, pat_mask, x_fwd, y_fwd, z

    if (num_monsters_ - num_killed_ < 2) {
        start()
        return
    }

    for (i = 0; i < length(o_[]); i++) if (o_[i]) {
        if (!o_z_[i]) {
            if (o_c_[i] < 3) {
                /* if the object is not out of view of the player for 3 frames */
                /* then move the monster otherwise it can stay hiding */

                if (is_not_valid_location(o_x_[i] + o_dx_[i], o_y_[i] + o_dy_[i])) {
                    /* if the enemy hit a wall then reverse its direction of travel */
                    o_dx_[i] = -o_dx_[i]
                    o_dy_[i] = -o_dy_[i]
                }
                /* move the enemy */
                o_x_[i] += o_dx_[i]
                o_y_[i] += o_dy_[i]

                moved_ = 1
            }

            if (!o_i_[i] && abs(o_x_[i] - player_x_) < 64 && abs(o_y_[i] < player_y_) < 64) {
                /* player ran into a health.  Make it go away and reward the player */
                /* set cz to 1 so that we do not display the flash of red */
                o_z_[i] = 1
                player_health_ += (64 - player_health_) / 4
                cz = 1
            }
        }
    }

    if (u_) { /* if we are rotating adjust the rotation angle */
        player_rotation_ -= u_ * rad_ /* playerRotation is the players view angle */
        moved_ = 1
    }

    if (fwd_) {
        scale = 20
        x_fwd = (player_x_ + fwd * cos(player_rotation_)) @ 0
        y_fwd = (player_y_ + fwd * sin(player_rotation_)) @ 0
        scale = 0

        if (!is_not_valid_location(x_fwd, y_fwd)) {
            player_x_ = x_fwd
            player_y_ = y_fwd
            moved_ = 1
        }
    }

    if (moved_) {
        moved_ = 0
        ray_cast()

        cz = 0
        scale = 20
        tx = cos(player_rotation_)
        ty = sin(player_rotation_)
        z = sqrt(tx * tx + ty * ty)
        scale = 0

        for (i = 0; i < length(o_[]); i++) if (o_[i]) {
            x = o_x_[i] - player_x_
            y = o_y_[i] - player_y_

            scale = 20
            o_d_[i] = sqrt(x * x + y * y) /* distance */
            o_a_[i] = acos((tx * x + ty * y) / (o_d_[i] * z))
            if (tx * x - ty * y < 0) o_a_[i] = -o_a_[i] /* error in wolf5k ? */

            scale = 0
        }

        sort_o()

        for (i = 0; i < length(o_[]); i++) if (o_[i]) {
            scale = 20
            ht = (64 / o_d_[i] * dist_to_proj_plane_) @ 0
            k = (player_eye_level_ - ht / 2) @ 0
            l = (player_eye_level_ + ht / 2) @ 0
            scale = 0

            if (k < 0) k = 0

            /* if i is zero then it is a monster, otherwise it is health */
            if (o_i_[i]) {
                pat = sp_enemy
                pat_mask = sp_enemymask
            } else {
                pat = sp_health
                pat_mask = sp_healthmask
            }

            scale = 20
            o_l_[i] = (w_ / 2 + o_a_[i] / r_ - ht / 2) @ 0
            scale = 0
            o_r_[i] = o_l_[i] + ht

            if (o_z_[i]) { /* determines if the object is dead */
                if (o_i_[i]) { /* if this is a monster */
                    pat = sp_dead /* set it to a dead monster sprite */
                    pat_mask = sp_deadmask
                } else {
                    continue
                }
            }

            if (o_i_[i] && !player_dead_ && o_c_[i] == 1 && !o_z_[i] && irand(100) < 5) {
                /* player hit */
                player_health_ -= irand(8)
                cz = 2
                if (player_health_ < 0) {
                    player_dead_ = 1 /* player is dead */
                    player_eye_level_ = h_ / 8 /* set the camera Y to 64/8 (fall down) */
                }
            }

            if (o_d_[i] > 64 && draw_sprite(pat, pat_mask, k, o_l_[i], l, o_r_[i], o_d_[i], 1)) {
                o_c_[i] = 1 /* 1 indicates the monster is visible */
            } else {
                o_c_[i] += 1 /* otherwise count frames monster not visible to player */
            }
        }

        draw_number(player_points_, 2, h_ + 1, 1)
        draw_number(num_monsters_ - num_killed_ - 1, 26, h_ + 1, 1)
        if (!player_dead_) {
            . = draw_sprite(sp_gun, sp_gunmask, h_ - 32, w_ / 2 - 16, h_, w_ / 2 + 16, 0, 1)
        }

        for (i = 0; i < player_health_; i++) {
            img__setpixel(canvas[], w_ - 2 - i, h_ + 3, black_)
        }

        show_screen(cz)
    }
}

clear_terminal()

while (1) {
    tick()
    u_ = 12
}
