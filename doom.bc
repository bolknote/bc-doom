#!/bin/zsh
x=/*
if ! command -v bc &>/dev/null; then
    echo The game requires BSD bc to run
    exit 1
fi

version=$(bc -V | awk '{print $2"\n6.5";exit}' | sort -Vr | head -1)
if [[ "$version" == "6.5" ]]; then
    echo Version 6.5.0 or higher of bc is required.
    exit 1
fi

ORIG=`stty -g`
trap "stty '$ORIG'" TERM EXIT
stty -echo

while {}; do
    v=
    read -rs -k1 -t0.4 v

    case "${v:l}" in
        [wasdljkm\ ]) printf "%d\n" "'${v:l}";;
        *)    echo 0;;
    esac
done | bc -g -Ll -f "$0"
exit; */1

define min(a, b) {
    if (a < b) return a
    return b
}

define max(a, b) {
    if (a > b) return a
    return b
}

define acos(a) {
    auto r

    if (a <= -1 || a >= 1) return 0 /* NaN if JS */
    return 2 * a(sqrt((1 - a) / (1 + a)))
}

define mod(a, b) {
    scale = 0; return a % b
}

define void swap_array(*arr[], pos1, pos2) {
    auto t
    t = arr[pos1]
    arr[pos1] = arr[pos2]
    arr[pos2] = t
}

/* base64 encode array and print */
define void base64_encode_and_print(bytes[]) {
    auto i, codes, chunk, len, b, bit, b6, index

    len = length(bytes[])

    for (i = 0; i < len; i+=3) {
        b6 = 0
        for (b = 0; b < 24; b++) {
            index = i + b / 8

            bit = (band(bytes[index] * (bits_[b % 8]), 128) && 1)
            b6 = b6 * 2 + bit

            if (mod(b, 6) == 5) {
                if (b6 < 26) print asciify(b6 + 65); else
                if (b6 < 52) print asciify(b6 - 26 + 97); else
                if (b6 < 62) print asciify(b6 - 52 + 48); else
                if (b6 < 63) print "+"; else print "/"

                if (index >= len) {
                    for (;mod(len, 3); len++) print "="
                    break
                }

                b6 = 0
            }
        }
    }
}

/* print array */
define void print_array(b[]) {
    auto i

    for (i = 0; i<length(b[]); i++) {
        print b[i], " "
    }
    print "\n"
}

/***** My own graphics library for bc *****/

black_ = 0
white_ = 1

/* create new image */
define void img__new(*img[], w, h, bg) {
    auto x, y
    img[0] = w; img[1] = h

    for (y = 0; y < h; y++) for (x = 0; x < w; x++) img[2 + x + y * w] = bg
}

/* helper for packing binary data */
define v_pack(*bytes[], bsize, offset, d) {
    auto i, m

    scale = 0
    for (i = 0; i < bsize / 8; i++) {
        d = divmod(d, 256, m[])
        bytes[i + offset] = m[0]
    }

    return i + offset
}

/* create mono BMP, encode by base64 and print */
define void img__monobmp(img[], colors[]) {
    auto b, s, bmp, size, i, x, y, wh, p

    scale = 0

    wh = ceil(img[0] / 8, 0)
    size = wh * img[1]

    bmp[s++] = 66; bmp[s++] = 77     /* BM */
    s = v_pack(bmp[], 32, s, 0)      /* space for Length */

    /* Main header */
    s = v_pack(bmp[], 16, s, 0)      /* Reserved */
    s = v_pack(bmp[], 16, s, 0)      /* Reserved */
    s = v_pack(bmp[], 32, s, 32)     /* Offset of image data */

    /* Subheader */
    s = v_pack(bmp[], 32, s, 12)      /* Subheader length */
    s = v_pack(bmp[], 16, s, img[0])  /* Width */
    s = v_pack(bmp[], 16, s, img[1])  /* Height */
    s = v_pack(bmp[], 16, s, 1)       /* Planes */
    s = v_pack(bmp[], 16, s, 1)       /* Bit count */

    /* Color table */
    for (i = 0; i < 6; i++) bmp[s++] = colors[i]

    for (y = img[1] - 1; y >=0; y--) {
        p = bmp[s] = 0

        for (x = 0; x < img[0]; x += 8) {
            for (b = 0; b < 8; b++) {
                bmp[s] = bmp[s] * 2 + img[2 + x + b + y * img[0]]

                if (x + b >= img[0]) {
                    bmp[s] *= bshl(1, wh - img[0])
                }
            }
            s += 1; p += 1
        }

        /* Row padding */
        for (; p % 4; p++) bmp[s++] = 0
    }

    s = v_pack(bmp[], 32, 2, length(bmp[])) /* Full length */

    base64_encode_and_print(bmp[])
}

/* Output image to iTerm2 terminal */
define void img__out_iterm2(img[], ratio, colors[]) {
    print "]1337;File=inline=1;width=", img[0] * ratio, "px;height=", img[1] * ratio, "px:"
    img__monobmp(img[], colors[])
    "" 
}

/* Set pixel */
define void img__setpixel(*img[], x, y, color) {
    if (x < img[0] && y < img[1] && x >= 0 && y >= 0) img[2 + x + y * img[0]] = color
}

/* Get pixel */
define img__getpixel(*img[], x, y) {
    if (x < img[0] && y < img[1]) return img[2 + x + y * img[0]]

    return black_
}

/* Draw line */
define void img__line(*img[], x1, y1, x2, y2, color) {
    auto step, dx, sx, dy, sy, e, t, i

    step = 0
    dx = abs(x2 - x1)
    if (x2 - x1 > 0) sx = 1; else sx = -1
    dy = abs(y2 - y1)
    if (y2 - y1 > 0) sy = 1; else sy = -1

    if (dy > dx) {
        step = 1
        t = x1; x1 = y1; y1 = t
        t = dx; dx = dy; dy = t
        t = sx; sx = sy; sy = t
    }

    e = 2 * dy - dx

    for (i = 0; i < dx; i++) {
        if (step) img__setpixel(img[], y1, x1, color); else img__setpixel(img[], x1, y1, color)

        while (e >= 0) {
            y1 += sy
            e -= 2 * dx
        }

        x1 += sx
        e += 2 * dy
    }

    img__setpixel(img[], x2, y2, color)
}

/* Draw rectangle */
define void img__rectangle(*img[], x1, y1, x2, y2, color) {
    img__line(img[], x1, y1, x2, y1, color);
    img__line(img[], x2, y1, x2, y2, color);
    img__line(img[], x2, y2, x1, y2, color);
    img__line(img[], x1, y2, x1, y1, color);
}

/* Draw filled rectangle */
define void img__filled_rectangle(*img[], x1, y1, x2, y2, color) {
    auto hx, lx, x

    hx = min(max(x1, x2), img[0])
    lx = max(min(x1, x2), 0)

    for (x = lx; x <= hx; x++) img__line(img[], x, y1, x, y2, color)
}

/* Draw bitmap */
define void img__number_bitmap(*img[], x, y, number, w, h, invert) {
    auto ix, iy, pixel
    scale = 0
    for (iy = 0; iy < h; iy++) for (ix = 0; ix < w; ix++) {
        number = divmod(number, 2, pixel[])
        img__setpixel(img[], x + ix, y + iy, bxor(pixel[0], invert))
    }
}

/**** Game code *****/

w_ = 128
h_ = 64
zoom_ = 4
map_size_ = 16 /* 16Ã—16 */

/*
map_ â€” map (16Ã—16)
z_ - z-buffer(128)
*/

player_points_ = num_killed_ = num_monsters_ = player_rotation_ = player_x_ = player_y_ = game_level_ =\
player_dead_ = fwd_ = u_ = 0
player_health_ = 64
moved_ = 1

rad_ = pi(15) / 180   /* used to convert angles to radians */
f_ = 30 * rad_        /* angle of view (larger distorts the "lens") */
dist_to_proj_plane_ = (64 / tan(f_)) @ 0 /* 110 pixels */
r_ = 2 * f_ / 128     /* this is the angle of each ray to cover 128 pixels */

player_eye_level_ = 32
inf_ = 1e300

c_180_ = pi(15)
c_90_ = c_180_ / 2
c_270_ = c_180 * 3 / 2

sbar_changed_ = 1 /* we need to rerender status bar */
sbar_h_ = 8

frame_delay_ = 0

for (i = 0; i < 16; i++) bits_[i] = bshl(1, i)

/* Sprites 16Ã—16 */
sp_[48]=sp_[49]=sp_[50]=sp_[51]=sp_[52]=sp_[53]=sp_[64]=sp_[65]=sp_[66]=sp_[67]=sp_[68]=sp_[69]=sp_[96]=\
sp_[97]=sp_[98]=sp_[99]=sp_[7U]=sp_[7V]=sp_[7W]=sp_[7X]=sp_[7Y]=sp_[7Z]=sp_[8W]=sp_[8X]=sp_[8Y]=sp_[8Z]=\
sp_[9Q]=sp_[9R]=sp_[9S]=sp_[9T]=sp_[9U]=sp_[9V]=sp_[AS]=sp_[AT]=sp_[AU]=sp_[AV]=sp_[AW]=sp_[AX]=sp_[AY]=\
sp_[AZ]=sp_[BY]=sp_[BZ]=sp_[CQ]=sp_[CR]=sp_[CS]=sp_[CT]=sp_[CU]=sp_[CV]=sp_[DU]=sp_[DV]=sp_[DW]=sp_[DX]=\
sp_[DY]=sp_[DZ]=sp_[EV]=sp_[EW]=sp_[EX]=sp_[EY]=sp_[EZ]=0;sp_[5]=4;sp_[4]=sp_[6]=E;sp_[1]=sp_[C]=sp_[E]=\
AS;sp_[EQ]=NQ;sp_[0]=sp_[2]=sp_[D]=448;sp_[45]=720;sp_[W]=sp_[39]=sp_[80]=sp_[87]=sp_[93]=sp_[BQ]=sp_[BX]=\
sp_[CW]=sp_[DT]=7SS;sp_[X]=sp_[38]=sp_[BR]=sp_[BW]=7UW;sp_[40]=sp_[8R]=8QS;sp_[46]=9TY;sp_[8Q]=sp_[9W]=\
sp_[9X]=GZY;sp_[47]=sp_[81]=sp_[86]=sp_[94]=sp_[95]=sp_[CX]=sp_[DS]=HVU;sp_[Z]=sp_[BU]=HWW;sp_[EU]=HZU
sp_[37]=sp_[BS]=JVY;sp_[ER]=KVQ;sp_[Y]=sp_[36]=sp_[BT]=sp_[BV]=KVU;sp_[8S]=sp_[8T]=NQW;sp_[9Y]=sp_[9Z]=4064
sp_[82]=sp_[83]=sp_[84]=sp_[85]=sp_[CY]=sp_[CZ]=sp_[DQ]=sp_[DR]=4092;sp_[9]=4096;sp_[55]=sp_[62]=4104
sp_[56]=sp_[57]=4488;sp_[43]=4740;sp_[8U]=sp_[8V]=5136;sp_[ET]=6096;sp_[58]=sp_[59]=6120;sp_[44]=7928
sp_[AQ]=sp_[AR]=8176;sp_[54]=sp_[63]=sp_[70]=sp_[71]=sp_[72]=sp_[73]=sp_[74]=sp_[75]=sp_[76]=sp_[77]=sp_[78]=\
sp_[79]=sp_[92]=8184;sp_[91]=8188;sp_[ES]=9544;sp_[60]=sp_[61]=9XZU;sp_[8]=sp_[A]=BUVQ;sp_[88]=FVTY
sp_[42]=TYVU;sp_[90]=TYXY;sp_[R]=TZXZ;sp_[Q]=UQSX;sp_[K]=UTZV;sp_[N]=VVTR;sp_[M]=WUVZ;sp_[O]=WVXR
sp_[P]=YWRZ;sp_[L]=YXTR;sp_[I]=sp_[T]=40965;sp_[S]=49155;sp_[J]=49667;sp_[H]=sp_[U]=53259;sp_[41]=65508
sp_[89]=65532;sp_[3]=sp_[7]=sp_[B]=sp_[F]=sp_[G]=sp_[V]=65535

/* Sprites offset */
sp_wall = 0
sp_5k = 16
sp_enemy = 32
sp_health = 48
sp_healthmask = 64
sp_enemymask = 80
sp_gun = 96
sp_gunmask = 112
sp_dead = 128
sp_deadmask = 144
sp_fire = 160

font[0] = 31599 /* 3Ã—5 */
font[1] = 18740 /* 3Ã—5 */
font[2] = 29671 /* 3Ã—5 */
font[3] = 31207 /* 3Ã—5 */
font[4] = 18925 /* 3Ã—5 */
font[5] = 31183 /* 3Ã—5 */
font[6] = 31695 /* 3Ã—5 */
font[7] = 18727 /* 3Ã—5 */
font[8] = 31727 /* 3Ã—5 */
font[9] = 18927 /* 3Ã—5 */

for (i = 0; i < w_; i++) z_[i] = 0

/* Draw number */
define void draw_number(number, x, y, invert) {
    auto len, i, digit, m

    if (number) len = l10(number) @ 0 + 1; else len = 1

    for (i = 0; i<len; i++) {
        m = 10 ^ (len - i - 1)
        digit = (number / m) @ 0
        number -= digit * m

        img__number_bitmap(canvas[], x, y, font[digit], 3, 5, invert)
        x += 4
    }
}

define is_not_valid_location(x,y) {
    x /= 64
    y /= 64

    if (x < 0 || y < 0 || x > map_size_ - 1 || y > map_size_ - 1) {
        return 1
    }

    return map_[x @ 0 + map_size_ * y @ 0]
}


/* Init world map */
define void init_map() {
    auto i, wall_cnt, x, y
    for (i = 0; i < map_size_ * map_size_; i++) map_[i] = 0

    wall_cnt = 30 + 4 * game_level_

    while (wall_cnt) {
        x = irand(map_size_)
        y = irand(map_size_)

        if (x * y > 4) {
            map_[x + map_size_ * y] = 1
            wall_cnt -= 1
        }
    }
}

define void init_objects() {
    auto i, x, y, type, o_cnt, k

    o_cnt = 0

    /* clear objects */
    for (i = 0; i < length(o_[]); i++) o_[i] = 0

    i = 6 + 4 * game_level_

    while (i) {
        x = 64 * (irand(12) + 2)
        y = 64 * (irand(12) + 2)
        type = (mod(i, 8) && 1) /* 0 â€” health, 1 â€” monster */

        if (!is_not_valid_location(x, y)) {
            o_x_[o_cnt] = x
            o_y_[o_cnt] = y
            o_i_[o_cnt] = type
            k = 1 - 2 * brand() /* 1 or -1 */

            if (type) {
                o_dx_[o_cnt] = k * (irand(64) / 4 * game_level_) @ 0
                o_dy_[o_cnt] = k * (irand(64) / 4 * game_level_) @ 0
                num_monsters_ += 1
            } else {
                o_dx_[o_cnt] = o_dy_[o_cnt] = 0
            }

            o_z_[o_cnt] = o_c_[o_cnt] = 0

            o_[o_cnt++] = 1 /* object exists */
            i -= 1
        }
    }

    sbar_changed_ = 1
}

define draw_sprite(sprite, sprite_mask, sy, sx, dy, dx, check, invert) {
    auto height, width, canvas_changed, x, y, px, py, clr, msk

    height = abs(dy - sy)
    width  = abs(dx - sx)
    canvas_changed = 0

    if (sy < 0) sy = 0
    if (dy >= h_) dy = h_ - 1

    for (x = sx; x < dx; x++) {
        /* if $f is zero then we draw as long as it is on the screen
           otherwise check zBuffer which holds scanline information
           for visibility, if something already occupies the at
           a closer depth then we know that whatever we were
           attempting to draw
           is hidden so we do not draw it */

        if (x >= 0 && x < w_) {
            if (!check || check <= z_[x]) {
                px = band(16 * (x - sx) / width, 15)

                for (y = sy; y < dy; y++) {
                    py = (16 * (y - sy) / height) @ 0

                    clr = (band(sp_[sprite + py], bits_[px]) && 1)
                    msk = (band(sp_[sprite_mask + py], bits_[px]) && 1)

                    if (msk) {
                        img__setpixel(canvas[], x, y, bxor(clr, invert))
                        canvas_changed = 1
                    }
                }
            }
        }
    }

    return canvas_changed
}

define void clear_terminal() {
    print "[2J"
}


define void show_screen(cz) {
    auto colors

    if (cz == 1) { /* invert */
        colors[0] = colors[1] = colors[2] = 255
        colors[3] = colors[4] = colors[5] = 0
    } else {
        colors[0] = colors[1] = colors[2] = 0
        colors[5] = 255
        colors[3] = colors[4] = 255 * (cz != 2) /* white or red */
    }

    if (!sbar_changed_) {
        canvas[1] -= sbar_h_
    }

    print "[H"
    img__out_iterm2(canvas[], zoom_, colors[])
    print "[H"

    if (!sbar_changed_) {
        canvas[1] += sbar_h_
        sbar_changed_ = 0
    }
}

define void start() {
    game_level_ += 1
    sbar_changed_ = 1
    player_x_ = player_y_ = 128
    num_killed_ = num_monsters_ = player_rotation_ = 0

    img__new(canvas[], w_, h_ + sbar_h_, white_)
    draw_number(game_level_, w_ / 2 - 2, h_ / 2, 1)
    show_screen(0)

    init_map()
    init_objects()

    frame_delay_ = 4
}

define void ray_cast() {
    auto c2, angle, a6, d, lht, c1, u, uh, uv, a5, a4, f, d2, dx, dy, d_b, q,\
    r, s, t, o, p, ht, d_a, v, dd, k, l, a0, b1, b2, pat, res

    img__new(canvas[], w_, h_ + 8, black_)
    img__filled_rectangle(canvas[], 0, h_, w_ - 1, h_ + 7, white_)

    c2 = -f_ /* f_ is the view angle, the larger f_ is the more we cram into the view area */
    angle = player_rotation_ + c2
    a6 = -1
    uh = uv = 0
    a5 = inf_

    f = 0

    /* what scanline we are working on (0-128) */
    for (v = 0; v < w_; v++) {
        c1 = f
        lht = ht

        c = cos(angle)
        s = sin(angle)
        t = s / c

        /* if angle is 0 or 180 then we get a divide by zero error so we ignore the ray */
        if (!angle || angle == c_180_) {
            a4 = inf_
        } else {
            if (s > 0) {
                d_b = 64 * ((player_y_ / 64 + 1) @ 0)   /* start at the tile in front of the player */
                dy = 64                                 /* increment in whole tiles forward */
                d_a = player_x_ + (d_b - player_y_) / t /* start with an adjustment to the side of the player */
                dx = 64 / t                             /* increment 64/t to the side (plot chart) */
            } else {
                /* otherwise we are facing backwards so we go in the opposite direction */
                d_b = ((player_y_ / 64) @ 0) * 64 - .0001
                dy = -64
                d_a = player_x_ + (d_b - player_y_) / t
                dx = -64 / t
            }

            /* while we have not hit a wall tile or edge of the map */
            while(!is_not_valid_location(d_a, d_b)) {
                d_a += dx /* keep shooting the ray */
                d_b += dy
            }

            q  = d_a  /* store the final location where the ray hits a wall tile */
            r  = d_b
            a4 = abs((player_x_ - d_a) / c)

            uh = mod(d_a, 64)   /* the pattern repeats every 64 pixels. */

            if (s > 0) {
                uh = 64 - uh    /* flip the pattern */
            }
        }

        /* if we are at 90 or 270 degrees our ray has infinite problems */
        if (angle == c_90_ || angle == c_270_) {
            a5 = inf_
        } else {
            if (c > 0) {
                d_a = ((player_x_ / 64 + 1) @ 0) * 64 /* start one tile in front of player */
                dx  = 64
                d_b = player_y_ + (d_a - player_x_) * t
                dy  = 64 * t
            } else {
                d_a = ((player_x_ / 64) @ 0) * 64 - .0001 /* start just behind player */
                dx  = -64
                d_b = player_y_ + (d_a - player_x_) * t   /* at 90 and 270, t goes to infinity so multiplying */
                                                          /* results in an invalid number */
                dy  = -64 * t
            }

            /* again look for the first wall tile we hit */
            while (!is_not_valid_location(d_a, d_b)) {
                d_a += dx
                d_b += dy
            }

            s = d_a
            t = d_b
            a5 = abs((player_x_ - d_a) / c)

            uv = mod(d_b, 64)
            if (c < 0) {
                uv = 64 - uv
            }
        }

        d = a6
        /* we are looking for the smallest distance to travel
           both rays cannot be infinite at once so we pick the one
           that is not infinite */
        if (a4 < a5) {
            u  = uh /* texture scanline */
            f  = a4 /* distance from camera */
            a6 = 0
            o  = q  /* map x position */
            p  = r  /* map y position */
        } else {
            u  = uv /* text scanline */
            f  = a5 /* distance from camera */
            a6 = 1
            o  = s /* map x position */
            p  = t /* map y position */
        }

        f *= cos(c2)

        z_[v] = f /* z-buffer, f is the depth of the scanline */

        ht = (64 / f * dist_to_proj_plane_) @ 0 /* height of the scanline */
        dd = abs(c1 - f) /* change in distance from previous f */
        k = (player_eye_level_ - ht / 2) @ 0 /* the top of our scanline */
        l = (player_eye_level_ + ht / 2) @ 0 /* the bottom of the scanline */

        b3 = k  /* starting position for scanning */

        /* a0 is the x pixel position in the texture
           u will go from 0 to 63 so dividing by 4 gets us 0 to 15*/

        a0 = bshr(u, 2)

        if (dd > 64 && lht > ht) {  /* Lht is the previous scanline height */
            ht = lht
        }

        if (k < 0) { /* make sure we are not trying to draw above the view area */
            k = 0
        }

        if (l >= h_) { /* if l is greater than the height of the view area then adjust */
            l = h_ - 1
        }

        x = (o / 64) @ 0 /* our tile position */
        y = (p / 64) @ 0

        /* if we're out of bounds of the map
           and the level is less than 5 then
           alternate wall tiles
           otherwise use the enemy sprite as a wall
           tile and alternate it.
           if we're in bounds then use the default
           wall tile 0 */

        if ((x<0 || x>15) && mod(y, 2)) {
            pat = sp_5k
        } else {
            if (game_level_ > 4) pat = sp_enemy; else pat = sp_wall
        }

        /* start at the top of the scanline and work down */
        for (y = k; y < l; y++) {
            /* the row of pixels is based on the current y
             y position. >>2 divides by 4.  64/4==16 */

            if (y - b3 < 0) {
                b1 = bshr(ceil((y - b3) / ht * 64, 0), 2)
            } else {
                b1 = bshr((y - b3) / ht * 64, 2)
            }

            b2 = (band(sp_[pat + b1], bits_[a0]) && 1)

            res = (b2 || /* is the color 1 or 0? */ \
                (v && d != a6) || /* is v 0 and d not equal to a6 (d is the prior version of a6) */ \
                (dd >= 64 && v) || /* if our change in distance is greater than 64 and v is non 0 */ \
                (f >= 64*3 && f < 64*4 && mod(v, 4) == mod(y, 4)) || /* skip pixels based on distance from player */ \
                (f >= 64*4 && f < 64*6 && mod(v, 3) == mod(y, 3)) || /* this is how the "lighting" is done */ \
                (f >= 64*6 && mod(v, 2) == mod(y, 2)))

            if (!res) {
                /* if after all of the checks we having something to plot */
                img__setpixel(canvas[], v, y, white_)
            }
        }

        angle  += r_  /* increment the ray angle */
        c2 += r_
    }
}

define void swap_o(pos1, pos2) {
    swap_array(o_a_[],  pos1, pos2)
    swap_array(o_c_[],  pos1, pos2)
    swap_array(o_d_[],  pos1, pos2)
    swap_array(o_dx_[], pos1, pos2)
    swap_array(o_dy_[], pos1, pos2)
    swap_array(o_i_[],  pos1, pos2)
    swap_array(o_l_[],  pos1, pos2)
    swap_array(o_r_[],  pos1, pos2)
    swap_array(o_x_[],  pos1, pos2)
    swap_array(o_y_[],  pos1, pos2)
    swap_array(o_z_[],  pos1, pos2)
}

define void quicksort_o(left, right) {
    auto pivot_index

    if (left < right) {
        pivot_index = partition_o(left, right)
        quicksort_o(left, pivot_index - 1)
        quicksort_o(pivot_index + 1, right)
    }
}

define partition_o(left, right) {
    auto i, j, pivot

    pivot = o_d_[right]
    i = left - 1
    for (j = left; j < right; j++) {
        if (o_d_[j] >= pivot) {
            i += 1
            swap_o(i, j)
        }
    }
    swap_o(i + 1, right)
    return i + 1
}

define void sort_o() {
    auto last_i, i
    for (last_i = i = 0; i < length(o_[]); i++) if (o_[i]) last_i = max(last_i, i)

    quicksort_o(0, last_i)
}

define void tick() {
    auto i, cz, tx, ty, x, y, ht, k, l, pat, pat_mask, x_fwd, y_fwd, z

    if (frame_delay_ > 0) {
        frame_delay_ -= 1
        return
    }

    if (num_monsters_ - num_killed_ < 1) {
        start()
        return
    }

    for (i = 0; i < length(o_[]); i++) if (o_[i]) {
        if (!o_z_[i]) {
            if (o_c_[i] < 3) {
                /* if the object is not out of view of the player for 3 frames */
                /* then move the monster otherwise it can stay hiding */

                if (is_not_valid_location(o_x_[i] + o_dx_[i], o_y_[i] + o_dy_[i])) {
                    /* if the enemy hit a wall then reverse its direction of travel */
                    o_dx_[i] = -o_dx_[i]
                    o_dy_[i] = -o_dy_[i]
                }
                /* move the enemy */
                o_x_[i] += o_dx_[i]
                o_y_[i] += o_dy_[i]

                moved_ = 1
            }

            if (!o_i_[i] && abs(o_x_[i] - player_x_) < 64 && abs(o_y_[i] - player_y_) < 64) {
                /* player ran into a health.  Make it go away and reward the player */
                /* set cz to 1 so that we do not display the flash of red */
                player_health_ += (64 - player_health_) / 4
                o_z_[i] =sbar_changed_ = cz = 1
            }
        }
    }

    if (u_) { /* if we are rotating adjust the rotation angle */
        player_rotation_ -= u_ * rad_ /* playerRotation is the players view angle */
        moved_ = 1
    }

    if (fwd_) {
        x_fwd = (player_x_ + fwd_ * cos(player_rotation_)) @ 0
        y_fwd = (player_y_ + fwd_ * sin(player_rotation_)) @ 0

        if (!is_not_valid_location(x_fwd, y_fwd)) {
            player_x_ = x_fwd
            player_y_ = y_fwd
            moved_ = 1
        }
    }

    if (moved_) {
        moved_ = 0
        ray_cast()

        cz = 0
        tx = cos(player_rotation_)
        ty = sin(player_rotation_)
        z = sqrt(tx * tx + ty * ty)

        for (i = 0; i < length(o_[]); i++) if (o_[i]) {
            x = o_x_[i] - player_x_
            y = o_y_[i] - player_y_

            o_d_[i] = sqrt(x * x + y * y) /* distance */
            o_a_[i] = acos((tx * x + ty * y) / (o_d_[i] * z))
            if (tx * y - ty * x < 0) o_a_[i] = -o_a_[i] /* error in wolf5k ? */
        }

        sort_o()

        for (i = 0; i < length(o_[]); i++) if (o_[i]) {
            ht = (64 / o_d_[i] * dist_to_proj_plane_) @ 0
            k = (player_eye_level_ - ht / 2) @ 0
            l = (player_eye_level_ + ht / 2) @ 0

            if (k < 0) k = 0

            /* if i is zero then it is a monster, otherwise it is health */
            if (o_i_[i]) {
                pat = sp_enemy
                pat_mask = sp_enemymask
            } else {
                pat = sp_health
                pat_mask = sp_healthmask
            }

            o_l_[i] = (w_ / 2 + o_a_[i] / r_ - ht / 2) @ 0
            o_r_[i] = o_l_[i] + ht

            if (o_z_[i]) { /* determines if the object is dead */
                if (o_i_[i]) { /* if this is a monster */
                    pat = sp_dead /* set it to a dead monster sprite */
                    pat_mask = sp_deadmask
                } else {
                    continue
                }
            }

            if (o_i_[i] && !player_dead_ && o_c_[i] == 1 && !o_z_[i] && frand(2) < .05) {
                /* player hit */
                player_health_ -= irand(8)
                cz = 2
                if (player_health_ < 0) {
                    player_dead_ = 1 /* player is dead */
                    player_eye_level_ = h_ / 8 /* set the camera Y to 64/8 (fall down) */
                }
            }

            if (o_d_[i] > 64 && draw_sprite(pat, pat_mask, k, o_l_[i], l, o_r_[i], o_d_[i], 1)) {
                o_c_[i] = 1 /* 1 indicates the monster is visible */
            } else {
                o_c_[i] += 1 /* otherwise count frames monster not visible to player */
            }
        }

        draw_number(player_points_, 2, h_ + 1, 1)
        draw_number(num_monsters_ - num_killed_, 26, h_ + 1, 1)
        if (!player_dead_) {
            . = draw_sprite(sp_gun, sp_gunmask, h_ - 32, w_ / 2 - 16, h_, w_ / 2 + 16, 0, 1)
        }

        for (i = 0; i < player_health_; i++) {
            img__setpixel(canvas[], w_ - 2 - i, h_ + 3, black_)
        }

        show_screen(cz)
    }
}

clear_terminal()

for(;;) {
    key = read()

    if (key == 108 || key == 100) {
        u_ = -12
    } else if (key == 106 || key == 97) {
        u_ = 12
    } else if ((key == 107 || key == 119) && !player_dead_) {
        fwd_ = 64/3;
    } else if ((key == 109 || key == 115) && !player_dead_) {
        fwd_ = -64/3;
    } else if (key == 0) {
        fwd_ = u_ = 0
    } else if (key == 32) {
        if (!player_dead_) {
            . = draw_sprite(sp_fire, sp_fire, h_ - 32, w_ / 2 - 16, h_, w_ / 2 + 16, 0, 0)
            show_screen(0)

            for (i = 0; i < length(o_[]); i++) if (o_[i]) {
                if (o_i_[i] && !o_z_[i] && o_l_[i] < w_ / 2 && o_r_[i] > w_ / 2 && o_c_[i] == 1) {
                    o_z_[i] = 1
                    num_killed_ +=1    /* numKilled is the kill count */
                    player_points_ += 10 * (game_level_ + (o_d_[i] / 64) @ 0)
                    sbar_changed_ = 1
                }
            }
            moved_ = 1
        }
    }

    tick()
}
